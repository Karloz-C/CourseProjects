### Project: report on the application of this deduce technique in Ethereum with ECDSA

#### 前置知识

##### 椭圆曲线

域k(特征0)上的椭圆曲线可看成由下面方程的解全体再加上一个无穷远点：$y^2=x^3+ax+b,(x,y)\in k^2$，a,b为常数，并且判别式$\Delta =-16(4a^3+27b^2) \neq 0$不等于0。(即为了光滑性要求无重根)。

椭圆曲线上的点全体构成一个加法群， 点与点之间的“加法”运算。 正因为椭圆曲线存在加法结构，所以它包含了很多重要的数论信息。

对于密码学，椭圆曲线是连续的，并不适合用于加密。因此，椭圆曲线密码学的第一要务就是把椭圆曲线定义在有限域上，（有限域$F_p$ ，p为素数），并提出一条适于加密的曲线：$y^2=x^3+ax+b\ (mod\ p)$。

椭圆曲线通常与离散对数问题关联。椭圆曲线上的离散对数问题是指，对于一个曲线上的点$P=k*G$，$G$为基点。已知$P$和$G$，计算k是困难的，这就引出了公钥密码学的应用。

相比起在商业中被广泛采用的RSA加密算法，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高级别的安全。通过下图我们清楚的发现，160位ECC加密安全性相当于1024位RSA加密，而210位ECC加密安全性甚至相当于2048位RSA加密。

##### ECDSA

即椭圆曲线数字签名算法，是DSA算法在椭圆曲线上的变形应用。

最原始的算法过程如下：

###### 公私钥生成

随机取整数$d_A\in [1,n-1]$作为私钥。n为椭圆曲线群的阶。

计算$Q=d_A*G$作为公钥，G为基点。

###### 计算签名

生成随机数k。

计算$P=k*G$，得到曲线上一个点

取$P$的坐标x，令$r=x\ (mod\ n)$

计算消息m的hash值H(m)

计算$s=k^{-1}*(H(m)+d_A*r)\ (mod\ n)$

输出$(r,s)$作为签名。

验证者需要得到签名对应的消息和公钥才可以验证签名合法性。

##### 比特币中的ECDSA

对于256位模数，私钥是256位的整数，而公钥两个坐标均为256位，共64字节。

而比特币交易的信息中，公钥信息占了较大的一部分。如果有方法可以降低公钥使用的大小，则可以有效地降低每笔交易整体的大小，使得一个区块可以承载更多交易，整个系统会更加高效。

一个很有效的优化是对于公钥的压缩。

对于已知的椭圆曲线，如果知道点的横坐标，根据曲线关于y轴对称的特性，可以得到两个可能的点。而这两个点事实上只需要1个bit就可以区分。这样就只需要保留32字节的横坐标x和额外的1位（实际的做法是以一个字节0x02或0x03来区分）来唯一标识一个点。从而将原来的64字节降低到33字节。

进一步地，如果能只根据签名值就能推导出公钥，那么就可以完全省去其占用的64字节。这引出了推导的技术。

#### 以太坊ECDSA

以太坊使用的ECDSA签名在原来的基础上引入了一个额外的恢复标识符v（1byte），签名值可表示成$(r,s,v)$。

简化的签名过程如下：

1.对待签署消息进行哈希计算，得到哈希值 $z=hash(m)$。

 2.生成一个安全的随机数 k。 

3.将 k 乘以椭圆曲线的常量 G，来计算椭圆曲线上的点$(x, y)$。 

4.计算$ r = x\ (mod\ n)$。如果 r 等于 0，返回步骤 2 。 

5.计算 $s = k(e + rd)\ (mod\ n)$。如果 s 等于 0，返回步骤 2。

验证签名时，不需要预先知道公钥。

简化的公钥恢复过程为：

1.计算消息的哈希值 $z=hash(m)$。

 2.计算椭圆曲线上的点 $R = (x, y)$，其中$x=r,r+n,r+2n\ldots$（根据v的值确定）。

3.计算 $u_1 = -z*r^{-1}\ (mod\ n)$ 和 $u_2 = s*r^{-1}\ (mod\ n)$。 

4.计算点 $Q = (x', y') = u_1 * G + u_2 * R$。

得到的点Q就是验证签名需要的公钥。

可以看到，这样实际上将原本公钥的横坐标信息放入了签名值的r中，不需要额外发送公钥。但是由于模n的计算，x的值有多种可能性。

如果没有v的存在，为了确定正确的Q，需要遍历x的所有可能取值，跑多轮Recover算法，这个时间开销是比较大的。为了提高Recover的时间效率，采用空间换时间的思路，在签名中增加一个v值，用于快速确定x，避免遍历查找试探，这个v值就是recoveryID。

由于$r = x\ (mod\ n)$，因此$r,r+n,r+2n\ldots$都可能是合法的原始x值，不同的椭圆曲线存在不同数量这样合法的x值，FISCO BCOS采用的secp256k1曲线存在两个可能$r, r+n$。

每一个X轴坐标对应两个可能的Y坐标，因此FISCO BCOS中具备四种可能的R，$(r, y),(r, -y),(r+n, y’),(r+n, -y’)$。但是，对于一个r值存在两个X轴坐标的概率极低，低到几乎可以忽略，以太坊中就忽略了这两种小概率事件。

由于$r = x\ (mod\ n)$，x是mod p的结果，r是mod n的结果，x值的范围是[0, p-1]，r值的范围是[0, n-1]。如果$r+n$也是曲线上的点，则r的值必须小于$p-n$，概率为 $(p-n) / p$，大约为$3.73*10^{-39}$，这个概率是非常小的。

基于签名结果$(r, s)$和签名过程中生成的随机点$(x, y)$的y值，recoveryID的计算方式如下：

1. id = y & 1; 

   签名算法S中kG点的y坐标，根据奇偶性设置id值，因为y是mod p的结果，其奇偶性与坐标轴的正负性是完全对应的。

2. id |= (x != r ? 2 : 0); 

   小概率事件，如前文解释。

3. if (s > n / 2) id = id ^ 1;

   签名计算得出的s如果大于n/2就会取n-s作为s值，因此这里做相应转换，这两个转换是同时发生的。

这样的算法设计使得验证者通过签名值就可以推导出正确的公钥，从而进一步验证签名合法性。仅仅引入了一字节的恢复标签v而降低了整个公钥的64字节信息，实现了极大的缩减。